#使用canvas绘图

###**绘图前提**

1. 先有一个canvas的html标签：```<canvas></canvas>```
2. 标签通常请客下，只有height和width两个宽高属性，  
   例如：```<canvas width='200' height='200'></canvas>  ```
   表示这个画布是宽高是200px，他所在的范围，就是画图的范围（超出部分无法绘图）
3. 前获取的canvas标签所在的DOM，和正常获取一个DOM方法一致（比如document.getElementById()）
4. 假设之前获取的DOM被赋给变量canvas，然后获取绘图用的渲染上下文，具体方法是：  
   ```var ctx = canvas.getContent('2d');```  
   这个ctx就是我们需要的绘图用的对象。  
   **调用接口时，如无特殊声明，都指的是通过这个ctx对象来调用**
   
###**0. 填充颜色和线条颜色**

###0.1 线条颜色####

**ctx.strokeStyle = color**

    1. 指线条，即stroke类方法描绘的轮廓的颜色；
    2. 该颜色不影响fill类方法填充时的颜色；

###0.2 填充颜色####

**ctx.fillStyle = color**

    1. color的类型可以是类似#000，或者rgb(0,0,0)，或者是rgba(0,0,0,0)这样形式；

**ctx.fillStyle = gradient**

    1. 用于使用渐变色，分为线性渐变和镜像渐变；
    2. 值是一个特殊对象，通过ctx来调用对应的API（线性或者镜像）创建；

镜像渐变：  
ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);

    1. 简单来说，通过两个圆来形成渐变背景图形；
    2. 第一个圆是渐变起始，第二个圆是渐变终止；
    3. 根据两个圆的相对位置关系不同，有三种情况，他们表现出的图案样式有所区别：
    3.0 染色时，范围大致可以分为以下几部分：最外层染色范围 > 次外层起始圆（终止圆）外 > 渐变区 > 最内层终止圆（起始圆）内
    3.1 【起始圆在终止圆内】：
        最内层：起始圆内全部被染成起始色;
        渐变区：起始圆最外围和终止圆的部分是渐变范围，最终渐变为终止颜色；
        最外层：终止圆外，绘图范围内是终止颜色；
        
    3.2 【起始圆在终止圆外】；
        最内层：终止圆内全部被染成终止色；
        渐变区：终止圆外，起始圆内为渐变区，渐变方向是从起始圆 -> 终止圆；
        最外层：起始圆外，染色范围内是起始色；
        
    3.3 【起始圆和终止圆相交】：
        比较复杂，想要理解，可以按照我说的画个图；
        首先，画起始圆和终止圆两个圆，他们会有一部分相交；
        此时，连接两个圆的圆心，然后再画两条线，这两条线线不与圆心连线（线段）相交，且每条线和每个圆有且只有一个交点；
        
    如图，图中左边的为起始圆，右边的为终止圆，起始颜色为红色，终止颜色为黄色，渐变中间色是绿色（即红-绿-黄）
        
![image](https://github.com/qq20004604/some_demo/blob/master/canvas/01.png)
        
        这样画出来的两条线（AC和BD），
        如果平行，则将染色区域划分为最多三部分：
        ①两条线之间的区域（两个圆存在的区域，图中MX和NY之间的区域）；
        ②③两条线以外的区域（以上和以下三个区域，MX线左上区域和NY左下区域）；
        如果相交，则将染色区域划分为最多四个部分：
        ①两个圆心所在区域；
        ②③④其他三个区域；（即多一个XM和YN线相交后延长线所包含区域）
        
        无论是哪种情况，实际染色区域只有①号区域，即两个圆圆心所在区域（即图中MNYX区域），该区域以外是为透明（不染色）。
        
        此时，实际染色区域可以分为以下区域：（先找到两条线和两个圆所相交的四个点）
        ①AB（左边弧）+DE（左边弧）+AC+BD共同框住的区域：（即图中ABDC四个点包含起来的F区域）
        ②这个区域一侧，靠近起始圆所在的区域；（即图中AMNB包裹起来的E区域）
        ③这个区域另一侧，靠近终止圆所在的区域 + 终止圆区域（即CDYX包含起来的G区域）；
        
        其中，②区域是起始色（E红），③区域是终止色（G黄）；
        剩下的是F区域，为渐变色区域


    4. 创建方法：
    4.1 先通过var gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);来创建一个镜像渐变的对象；
    4.2 x0和y0表示起始圆的圆心坐标，r0表示起始圆的半径；
    4.3 x1,y1表示终止圆的圆心坐标，r1表示终止圆的半径；
    4.4 设置颜色：gradient.addColorStop(number, color);
    4.5 number表示在渐变区域的该位置，颜色是什么颜色；
    4.5.1 当值为0时为初始色，值为1时为终止色；
    4.5.2 当0~1之间时，例如0.4，则表示从渐变区域的起始位置，往终止位置移动总距离的40%处的颜色为color
    4.6 color可以是"#000"这样或者rgb或者rgba，类型是字符串；
    4.7 然后使用ctx.fillStyle = gradient;赋值颜色即可；
    
线性渐变：  
ctx.createLinearGradient(x0, y0, x1, y1)

    1. 和镜像渐变类似，只不过线性渐变是从某位置渐变到另外一个位置（点到点，镜像渐变是圆到圆）；
    2. x0和y0是渐变起始坐标；
    3. x1和y1是渐变终止坐标；
    4. 具体来说，可以这么理解：
    4.1 在起始坐标和终止坐标之间，连一条线段；
    4.2 在起点和终点，分别画一条直线，这两条直线平行并且垂直于这条线段；
    4.3 这两条直线之间的区域，就是渐变区域；
    4.4 起点的直线的颜色为起始颜色，终点的直线的颜色为终止颜色；
    4.5 不能理解两条线中间的颜色的人（自己去写写代码就懂了，解释起来好麻烦）；
    5. 设置颜色同镜像渐变；

**ctx.fillStyle = pattern**

    1. 用于将图片作为背景色
    2. 请注意，由于图片可能没有加载好，所以务必确认画图时，需要使用的图片已经加载完毕；
    3. 需要调用API创建一个对象（在创建的时候需要加载一个HTML图片元素作为参数）;
    4. 可以设置x、y轴上的重复属性；
    5. 将这个对象赋值给ctx.fillStyle
    示例代码：
        var c = document.getElementById("circle3");
        var ctx = c.getContext("2d");
        var img = new Image();
        img.src = "./02.png";
        img.onload = function () {
            var pat = ctx.createPattern(img, 'repeat');
            ctx.fillStyle = pat;
            ctx.beginPath();
            ctx.moveTo(60, 50);
            ctx.arc(60, 50, 40, 0, 2 * Math.PI);
            ctx.fill();
        }
    6. 以上代码画出了一个圆，这个圆的内容是图片，关键在于显示图片哪个区域；
    7. 具体而言，这个图片的位置，由canvas决定，可以理解为，在调用createPattern时，决定该图片的url和repeat属性；
    8. 其中第一个参数的图片的url是canvas的background-image的url属性值；
    9. 第二个参数是background-repeat的值；
    10. 而染色时，有一个染色区域，这个染色区域将canvas上对应位置的区域图片显示出来；
    11. 而图片本身位置是相当于canvas标签是确定的（不受绘图时设置的属性所影响）；
    12. 即使改变HTML图片元素的margin属性、background-position属性或者其他属性都无法影响；
    13. 如果有办法，请加我QQ：20004604，或者发邮件到20004604@qq.com告诉我，谢谢。

###**1. 绘制矩形**

**fillRect(x, y, width, height)**

    1. 绘制一个矩形；
    2. 该矩形为填充满的；
    3. x和y指矩形左上角，相对于画布的坐标。
    4. x和y的标准范围是x:0~width, y:0~height
    5. 参数是number类型，不是字符串类型；
    6. 示例：ctx.fillRect(10, 20, 50, 50);
    7. 关于参数的解释，下同；

**strokeRect(x, y, width, height)**

    1. 绘制一个矩形；
    2. 该矩形只有边框；
    3. 该矩形内部透明；

**clearRect(x, y, width, height)**

    1. 清除一个矩形区域；
    2. 该矩形区域内内容被清除，变为透明；


###**2. 绘制路径**

解释：

    1. 简单来说，是绘制几条边，然后这几条边围城一个封闭图形，就完成了一个图形；
    2. 绘制过程中，建议不要去做其他事，原因见流程3-5；
    3. 开始绘制：ctx.beginPath();
    4. 绘制中：略，此时只有线条，但是没有图形（轮廓也没有，线条是看不见是，只是为最后一步做准备）；
    5. 结束绘制：ctx.fill()或者ctx.stroke()，前者填充满图形，后者只有线条轮廓；
    6. 因为是一个封闭的过程，所以虽然也可以在绘制过程中去完成其他的绘图（不是所有都可以），但是这样不利于维护，因此还是建议分开写；

API：

**beginPath()**

    1. 生成一条路径；
    2. 这条路径是母路径，在绘制过程中，会生成很多条子路径，
    3. 子路径最终构成的就是我们想要的图形
    4. 另外，虽然这个方法可以多次调用（至少在我的浏览器可以），但是建议还是按照上面流程来完成，这样至少代码可维护性好，不易发生BUG；

**closePath()**

    1. 闭合路径；
    2. 简单来说，就是从线条绘制到当前位置时的坐标，和起点连线；
    3. 起点是指调用beginPath后，移动到的第一个点；
    4. 这个点可能是moveTo的参数，也可能是lineTo的参数，或者其他。但总之，第一条路径一般视为于moveTo

**stroke()**

    1. 描绘轮廓；
    2. 通俗的说，就是你线条怎么画的，他给你把线条染色（没染色前是看不见的）；
    3. 这个只染轮廓不填充；

**fill()**

    1. 填充线条；
    2. 这个填满被线条包围的区域；
    3. 重点是包围的区域，比如你画个五角星（线条穿来穿去），那么五角星内部的五边形和五个三角形会被填充，外部不会；
    4. 在调用beginPath()之前，染色视为最后一次的fillStyle的颜色；

**moveTo(x, y)**

    1. 移动画笔；
    2. 移动过程中不会产生线条；
    3. 可以把这个理解为把笔抬起来，然后移动到新地方后再把笔放下来；

**lineTo(x, y)**

    1. 画一条直线；
    2. 起始位置是当前笔的位置；
    3. 参数是笔移动后的终点位置（相对于画布的坐标）；
    4. 终点位置是下一次画图时，笔的起始位置；

**arc(x, y, radius, startAngle, endAngle, anticlockwise)**

    1. 画一个圆弧；
    2. x和y是圆心相对于画布的坐标；
    3. radius是圆的半径；
    4. startAngle和endAngle是起始角度和终止角度，单位是弧度，2 * Math.PI是360度；
    5. anticlockwise表示顺逆时针，false为顺时针，true为逆时针；
    6. 起始坐标是圆的正右方位置

###**3. 画矩形**

0.颜色

    使用API：fillStyle(color)来完成

1.画未填充的矩形

    1. 画未填充的矩形还是很简单的；
    2. 首先确定矩形左上角顶点的位置；
    3. 再确定矩形的宽高；
    4. 使用strokeRect(x, y, width, height)，将数据输入即可；
    
2.画填满的矩形

    1. 画未填充的矩形还是很简单的；
    2. 首先确定矩形左上角顶点的位置；
    3. 再确定矩形的宽高；
    4. 使用fillRect(x, y, width, height)，将数据输入即可；（和上面的区别在这一步）
    
3.画内有空隙的矩形

    1. 典型来说，比如外边有个大矩形，内部有个小矩形，两个矩形之间被染色，而内部小矩形是透明的；
    2. 先按照2的方式画个矩形；
    3. 然后使用clearRect(x, y, width, height)清空小矩形区域的图形即可；
    
###**4. 画圆形**

0.颜色

    使用stroke()（轮廓颜色）或者fill()（填充颜色）完毕后，再更换颜色开始下一次绘图
    
1.画圆形

    0. 调用ctx.beginPath()开始画路径;
    1. 确定圆心坐标和圆半径
    2. 调用ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)方法
    3. x和y填圆心坐标，radius填半径；
    4. startAngle填开始角度，endAngle填结束角度，注意，角度为0时，起始点为圆心正右方；
    5. 角度为弧度，弧度和角度的换算是360角度 = 2π弧度；
    6. 最后一个参数不填或者为false时，表示默认顺时针绘图，否则为逆时针绘图；
    7. 可能会产生一个bug，原因和解决方式见下面画两个圆

2.画两个圆形

    1. 大部分和1相同；
    2. 正常流程是通过beginPath()——》画一个圆——》fill()或者stroke()，重复这个流程画下一个圆；
    3. 如果不是这样的流程的话，那么需要看第四条
    4. 需要使用moveTo来将画笔从第一个圆的终止处，移动到第二个圆画图时的起始处（你要画图的圆弧的起始处），然后再开始画下个圆；
    5. 圆形就调用fill()，圆弧就调用stroke()
    6. 如果非满圆的话，注意结果不是扇形，是一个圆被一刀切掉一部分后的样子（具体自己画一下就理解了，或者看DEMO）；

3.画圆弧

    1. 大部分和1相同；
    2. 需要注意的是笔记的轨迹；
    3. 在beginPath()后可以直接开始画圆弧，因为自带moveTo效果；
    4. 画完后直接调用stroke()方法来收尾给线条染色；
    5. 连续画圆弧的话，建议走beginPath()——》画一个——》stroke()，然后下一轮的方式，比较稳妥；

4.画扇形

    1. 大部分和画圆相同；
    2. 需要先手动移动画笔到圆心，再调用arc方法来画图，不然画出来的就不是一个扇形；
    3. 参照DEMO里第二个图和第三个图的区别，就是圆和扇形的区别了；

###**5. 将图片绘制到画布之上**

解释：

    1. 简单来说，就是将一张图的某个区域，画到画布上的某个区域；
    2. 和ctx.fillStyle = pattern不同的是，pattern是将图片作为背景，该背景位置是固定的，画图只是显示那背景某个区域；
    3. 而本方法画图是取图的全部/一部分（比如400x400的，取他(x:200,y:250,width:50,height:100)区域的图；
    4. 然后放在画图的某个指定区域（如坐标x:100,y:200处），也可以缩放图片大小（比如变为width:300,height:200）；
    5. 运用场景示例：有一个人物八方向四帧动作图，在一个png图上，可以根据需要，只取其中一个，然后绘制到画布区域之中；

**ctx.drawImage(image, dx, dy)**

    1. 将图片完整绘制在画布的x, y坐标处；
    2. x, y是图片绘制时，其左上角位于画布的坐标，参数类型是Number（不是有px的字符串类型）；
    3. 不会对图片进行缩放（即保持图片本身大小）；
    4. image是图片HTML元素，例如通过document.getElementById()获取的HTML的image元素，或者是在JS中，通过new Image()创建的图片元素；
    5. 需要小心一件事，图片在创建后，并不会立刻从服务器下载完成，因此假如图片是后续加载的话，务必要等图片onload事件触发后，再进行绘图；
    6. 应对办法：提前将图片下载好，这样绘制的时候就不必担心图片未加载完成的问题了。

**ctx.drawImage(image, dx, dy, dWidth, dHeight)**

    1. 将图片绘制在画布的x, y坐标处；
    2. 本方法在上一个方法的基础上，增加了缩放功能，dWidth和dHeight表示绘制到画布上时，画布上图片的宽高；
    3. 具体来说，假如一个图片是100*100，dWith和dHeight是200*200，就相当于将图片缩放了200%；

**ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)**

    1. 取出图片的某个区域，然后绘制到画布的某个区域；
    2. dx, dy, dWidth, dHeight和上面2个API表示的内容是一样的；
    3. sx表示图片（即image）取图时的x坐标，sy表示y坐标，sWidth表示从sx开始取的图片的宽度，sHeight表示从sy开始，取的图片的高度；
    4. 示例：假如image的宽高是200*200，这四个参数的值依次是50,50,100,100的话，表示取图片x:50, y:50到x:150, y:150这个范围的区域；
    5. sWidth + sx的值或者sHeight + sy的值可以大于图片本身的宽高，在缩放时，会将超出部分计算在内进行缩放，超出部分视为透明，不会染色；
    6. sWidth和sHeight可以是负数，有效，计算时同样相加即可，同样可以框住一个矩形区域。

具体请参照DEMO：绘制图片.html

###**6. 写文字**

解释：

    1. 可以绘制空心文字或者实心文字；
    2. 在绘制前可以定义三种属性：
    3. 定义完属性（或使用默认的）后，绘制文字到画布上。

**ctx.font**

    1. 字体和字体大小，类型是字符串。
    2. 和font-family类似，只不过多了一个字体大小的设置。
    3. 示例："Bold 10px Arial"先取Bold字体，如果没有则取Arial字体。字体大小取12px.

**ctx.textAlign**

    1. 字体对其方式，类型是字符串；
    2. 取值有left, center, right三种。
    3. 相对于绘制时的坐标，决定文字的排版方式。
    4. 绘制时的坐标，位于文字的下方。即假如是左对齐，绘制时的坐标是文字的左下角的坐标。

**ctx.fillStyle**

    1. 实心文字的颜色，就像普通写颜色css属性那样写；

**ctx.strokeStyle**

    1. 空心文字的颜色；

**ctx.fillText(text, x, y [, maxWidth])**

    1. 填充实心文字；
    2. x，y表示写文字时，基准位置的坐标点。左对齐是文字左下，居中是文字中间下方，右对齐是文字右下；
    3. maxWidth可以不加，加的话，会压缩文字的宽度（高度不会变化），而不是超出部分不显示；

**strokeText(text, x, y [, maxWidth])**

    1. 填充空心文字（需要字体支持）；
    2. 其他和上面没区别；


###**7. 画布的读取和写入**

解释：

    1. 简单来说，就是通过一个API保存当前画布某部分区域的图案；
    2. 然后可以通过另外一个API来恢复保存时的图案，可以恢复到某个指定位置；
    3. 保存时，返回一个变量，这个变量是一个对象：
       他有width和height属性表示画布宽高；
       还有data属性，用于保存画布各个像素的状态；
       data属性是一个数组，其保存原理是通过每个像素的rgba属性来保存；
       因为rgba是4个属性，分别表示红、绿、蓝、透明度，值的范围是0~255（包括透明度，255表示不透明）；
       因此，每个像素占用数组中四个位置。
       然后这么做的，先取出坐标0,0点像素的四个属性，放在data属性数组中（此时data属性有四个元素）；
       然后再找出坐标1.0点像素的四个属性，再放进去（此时data属性中有八个元素）；
       然后放完画布上y=0的所有像素，再开始放y=1的所有像素，依次类推。
    4. 当已知data属性的存储原理时，可以通过修改data属性中，数组的元素的值，来修改存储的图像；
    5. 例如，将每个像素表示透明度的元素的值，修改为比较小的值，则存储的图像信息则变为半透明了（注意，此时原图像没又被改变）。
    6. 然后将修改后的存储的图像信息，通过api写入canvas，则新的图像变为半透明了。

**ctx.getImageData(x, y, width, height);**

    1. 简单来说，就是从画布的x，y坐标开始，取width宽height高的矩形区域的图像信息，返回一个对象；
    2. 这个对象就是存储了图像的宽高和所有像素的信息；
    3. 恢复图像时，需要使用这个方法返回的对象；
    4. 如果width或者height为0，则可能会抛出错误（应避免）；
    5. 返回值是一个ImageData对象；

**ctx.putImageData(imagedata, dx, dy)**

    1. 简单来说，就是将getImageData这个api返回的对象，通过这个api将存储的图像放置在起始坐标为（dx, dy）的地方；
    2. 设置时，图像的默认宽高是存储的原图像的宽高；
    3. 不会对存储的图像进行缩放；
    4. 图像绘制后，超出画布显示区域的，不会被显示。

**ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)**

    1. 简单来说，从原图像中，取出一部分，然后放到画布中。
    2. 具体来说，从原图像中，取出起始坐标为（dirtyX, dirtyY），宽高为（dirtyWidth, dirtyHeight）的矩形区域，然后绘制到画布上起始坐标（dx， dy）的区域；
    3. 同样，对图像绘制时，不会进行缩放；

DEMO见链接：[DEMO](url:http://htmlpreview.github.io/?https://github.com/qq20004604/some_demo/blob/master/canvas/Canvas%E7%BB%98%E5%88%B6%E4%B8%80%E5%BC%A0%E6%8A%98%E7%BA%BF%E5%9B%BE.html)

###**8. 将canvas转为图片可用的base64字符串**

解释：

    1. 简单来说，就是将canvas标签的画布内容，转为base64字符串；
    2. base64字符串作为img标签的src，是可以直接显示为图片的；

**canvas.toDataURL(type, encoderOptions)**

    1. 返回一个base64字符串；
    2. type可选，表示图片的转换目标类型，类型是字符串，默认是"image/png"，如果传的类型不支持/错误，也会自动转为默认的png格式的base64字符串； 
    3. encoderOptions可选，表示图片质量，范围0-1，1质量最好，如果超出取值范围，将会使用默认值0.92；
    4. 该字符串可以作为img标签的src的值，可以正常显示为图片。

注：

    1. 不知为何，在未设置strokeStyle时，我画一个矩形，我转为“image/jpeg”类型图片，输出的图片是纯黑色（见DEMO）：
    2. 不知为何，图片质量我设置后并没有生效（值为1和值为0.1转换出来的字符串，其值是相同的，见DEMO）；

DEMO见链接：[DEMO](url:http://htmlpreview.github.io/?https://github.com/qq20004604/some_demo/blob/master/canvas/%E5%B0%86Canvas%E8%BD%AC%E4%B8%BA%E5%9B%BE%E7%89%87.html)


###**9. 保存画笔状态和恢复画笔状态**

解释：

    1. 简单来说，就是保存当前ctx设置的各种属性，在需要时，可以恢复到保存时的属性；
    2. 保存api是无返回值的，这说明不能保存多种不同的状态；
    3. 只能恢复一次，如果恢复后还需要保存，则需要再次调用保存的api；

**ctx.save()**

    1. 保存的api，无返回值；
    2. 保存状态只能恢复一次；
    3. 也可以说是保存ctx的上下文环境；
    4. 根据MDN的说明，保存的状态有以下：
 
```
    当前的变换矩阵。
    当前的剪切区域。
    当前的虚线列表.
    以下属性当前的值： strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled.
```

**ctx.restore()**

    1. 恢复保存时的状态，无返回值；
    2. 恢复只能恢复一次，第二次恢复无效；
    3. 恢复的内容显然是保存时的内容（见上面）；

[DEMO](url:http://htmlpreview.github.io/?https://github.com/qq20004604/some_demo/blob/master/canvas/sava%E5%92%8Crestore.html)

###**10. API简单说明**

解释：

    1. 写这个的目的只是熟悉API的功能，因此不会去像上面那样写DEMO和一一验证；
    2. 只写API和API的功能，具体请参照MDN；
    3. 或许存在兼容性问题，用的时候请注意；
    4. 不保证完全正确，有些只是根据经验推测；

[MDN关于canvas的API](url:https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D)

**ctx.canvas**

    1. 通过ctx来获取canvas的html元素；
    2. 如果不存在则返回null；
    3. 是变量而不是函数

**ctx.direction = "ltr" || "rtl" || "inherit";**

    1. 兼容性极差；
    2. ltr文本从左往右；
    3. trl文本从右往左；
    4. 默认无效，需通过某个方法来开启；


**ctx.filter = "<filter-function1> [<filter-function2] [<filter-functionN]";**

    1. 兼容性极差；
    2. 提供类似css3的filter功能；
    3. 类似模糊、灰度等。

**ctx.globalAlpha**

    1. 绘制图形／图片的透明度；
    2. 对图形有用（比如fillRect绘制的），对图片应该也有用；
    3. 兼容性很好

**ctx.globalCompositeOperation = type**

    1. 设置图像重叠后的效果；
    2. type是字符串，值有很多种；
    3. ‘source-over’：默认值，旧的覆盖新的；
    4. ‘source-in’：只有新的和旧的重叠时才绘制，并且都是透明的（旧的图透明的部分且新的图不存在，可能会被移除）；
    5. ‘source-out’：新的只绘制在旧的不存在的地方，旧图形将被相对移除（注意，旧的透明的地方会对应让新的也透明，透明度的总和是不透明）；
    6. ‘source-atop’：新图形只在和旧图形重合的地方绘制（旧的图形会被保留，透明度应该是采用旧的图形的透明度）；
    7. ‘destination-over’：将新图形绘制在旧图形之下（默认是之上）；
    8. ’destination-in‘：现有画布内容保持在新形状和现有画布内容重叠的位置。 一切都是透明的。
    9. ’destination-out‘：相当于从画布中扣出新的图形所占的区域的旧图形；
    10. 其他略，查看MDN吧

type说明更多请参照：https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing

**ctx.imageSmoothingEnabled**

    1. 设置图片是否平滑；
    2. 默认为true（平滑）；
    3. 根据说明，对像素游戏缩放画布时有用，在缩放时需要改为false避免模糊；
    4. 兼容性一般；

**ctx.lineCap**

    1. 线条末端以什么形状结束；
    2. ’butt‘：方形；
    3. ’round‘：圆形（半圆）；
    4. ’square‘：方形，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域（相当于多了一截）；

**ctx.setLineDash(segments)**

    1. 绘制虚线；
    2. 参数是一个数组，数组元素的类型是number类型；
    3. 如果是偶数，则依次表示实线、虚线的长度；
    4. 如果是奇数，则将数组元素复制一份放在原数组后面，然后依次表示实线，虚线的长度；

**ctx.lineDashOffset**

    1. 和上面搭配使用，用于设置虚线和初始位置的偏移量；
    2. 值为number类型，正值则原线条往左移动（往后退，逆时针），负值则往右移动（往前进，顺时针）；

**ctx.lineJoin**

    1. 两条线如何相连，类型是字符串；
    2. ’round‘：圆角；
    3. ’bevel‘：矩形拐角，不是直接的折线，而是类似六边形那样的角；
    4. ’miter‘：直角；

**ctx.shadowColor**

    1. 阴影颜色；
    2. 不设置则默认为透明（无阴影）；

**ctx.shadowBlur**

    1. 描述模糊度；
    2. 推测是模糊的左右偏移的总宽度；
    3. 值的类型是number，默认是1（几乎无模糊，但似乎还是有）；
    4. 值为0时则会导致线条不存在；

**ctx.shadowOffsetX**  
**ctx.shadowOffsetY**

    1. 阴影在x, y轴的偏移距离；
    2. 值类型是number

**ctx.textBaseline = "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom";**

    1. 文字垂直方向的对齐方式；
    2. 这个描述的是字相对基线的位置；
    3. top：文本基线在文本块的顶部。
    4. hanging：文本基线是悬挂基线。
    5. middle：文本基线在文本块的中间。
    6. alphabetic：文本基线是标准的字母基线。
    7. ideographic：文字基线是表意字基线；如果字符本身超出了alphabetic 基线，那么ideograhpic基线位置在字符本身的底部。
    8. bottom：文本基线在文本块的底部。 与 ideographic 基线的区别在于 ideographic 基线不需要考虑下行字母。
    9. 默认值是 alphabetic。

**ctx.addHitRegion(options);**

    1. 兼容性差，需要额外设置浏览器偏好；
    2. 用于设置画布点击的情况。

**ctx.quadraticCurveTo(cpx, cpy, x, y)**

    1. 绘制二次贝塞尔曲线的方法；
    2. 起始点是当前路径最后一个点，(cpx, cpy)是控制点，(x, y)是终点；

**ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)**

    1. 绘制三次贝赛尔曲线路径的方法；
    2. 第一（cp1）、第二（cp2）个点是控制点，第三个点（x，y）是结束点。起始点是当前路径的最后一个点；

**ctx.clearHitRegions()**

    1. 兼容性差；
    2. 在画布中删除所有点击区域的方法；

**ctx.clip()**  
**ctx.clip(fillRule)**  
**ctx.clip(path, fillRule)**

    1. 简单来说，这个是用于画出一个区域（规则或不规则），然后后面新画的所有东西都只能在这个区域内生效；
    2. 可以理解为新建一个图层，这个图层是之前画的路径所创建的，然后新画的东西就被画在这个图层上生效，然后这个新图层和原有图层合并。
    3. 有了这个之后，就可以从原图里画图而不必担心新画的图超出预期范围了。
    4. 更多请参照链接：http://jo2.org/html5-canvas-clip/

**ctx.createImageData(width, height)**  
**ctx.createImageData(imagedata)**

    1. 创建一个新的、空白的、指定大小的ImageData对象；
    2. 带宽高的是指定宽高；
    3. 不带宽高的，是和指定imagedata对象宽高相同（但是不会复制图像，纯宽高）；
    4. 上面还有putImageData()方法和getImageData()方法；
    5. 不过

**ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)**

    1. 兼容性差
    2. 绘制椭圆路径

**ctx.getLineDash()**

    1. 获取ctx.setLineDash(segments)设置的参数；
    2. 如果没设置过，则是空数组；
    3. 如果设置的是数组元素是奇数个，返回的是补全后的偶数个元素的数组。

**ctx.isPointInPath(x, y)**  
**ctx.isPointInPath(x, y, fillRule)**  
**ctx.isPointInPath(path, x, y)**  
**ctx.isPointInPath(path, x, y, fillRule)**

    1. 按照说明，是检测一个点是否在路径之内；
    2. 但是如何描述这个路径我表示不太明白；

**ctx.rect(x, y, width, height)**

    1. 绘制路径；
    2. 然后可以通过fill()来填充或者stroke()来描边；
    3. fillRect()和strokeRect()是一步完成的，而这个需要两步（路径->填充）；

**ctx.rotate(angle)**

    1. 让画图时的参考坐标系旋转；
    2. 也就是说，原来画个矩形，是正常x、y轴；通过这个方法旋转后，那么矩形就变倾斜了（因为参考系xy轴被旋转了）；
    3. 旋转的原点是坐标轴的原点（x:0, y:0)；
    4. 参数是弧度，正数是顺时针旋转，负数是逆时针旋转；
    
**ctx.scale(x, y)**

    1. 缩放功能，也可以达到上下/左右反转；
    2. (1, 1)是默认情况；
    2. x指水平方向（以x=0的y轴为参考对象）缩放，如果(-1,1)则表示水平反转（以y轴为镜像的对称轴）
    3. y指垂直方向的缩放比例，如果(1,-1)那么将垂直反转（以x轴为镜像的对称轴）

**ctx.setTransform(a, b, c, d, e, f)**

    1. 个人理解就是对坐标轴的变化操作；
    2. a：水平缩放，x轴，默认1（参照之前的缩放）；
    3. b：水平倾斜，x轴，默认0（有点类似rotate，但那个影响的是全部，这个只影响一个轴，下同），1的话，相当于坐标的y的值*2（往下偏移原坐标100%的距离）；
    4. c：垂直倾斜，y轴，默认0（注意，不是缩放），1的话，相当于x值*2（往右偏移100%）；
    5. d：垂直倾斜，y轴，默认1；
    6. e：水平偏移（不是百分比移动，是和canvas的width，height一样，移动一个单位）；
    7. f：垂直移动（同上）；
    8. 参数都是数字；
    9. 这个方法【会覆盖】当前的变换矩阵，多次调用只引用最新的那个；

**ctx.transform(a, b, c, d, e, f)**

    1. 类似上面那个方法；
    2. 但这个区别是，这个方法【不会覆盖】当前的变换矩阵，都调用则会覆盖；
    3. 叠加的计算方式，是对应参数相加（而非相乘）；

**ctx.translate(x, y)**

    1. 移动坐标轴；
    2. 相当于setTransform第5，6个参数的操作；